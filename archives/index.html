
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="JACE SHIM">
    <title>Archives - JACE SHIM</title>
    <meta name="author" content="Jace Shim">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="Software developer, Baseball Player">
<meta property="og:type" content="blog">
<meta property="og:title" content="JACE SHIM">
<meta property="og:url" content="http://jaceshim.github.io/archives/index.html">
<meta property="og:site_name" content="JACE SHIM">
<meta property="og:description" content="Software developer, Baseball Player">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JACE SHIM">
<meta name="twitter:description" content="Software developer, Baseball Player">
    
    
        
    
    
        <meta property="og:image" content="http://jaceshim.github.io/assets/images/profile.jpg"/>
    
    
    
    
    <link rel="stylesheet" href="https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css">	
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothiccoding.css">      
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-z2svfddshdg8rqvbyid44co3r0i37pnbeahhkfyhfvdbvar6nl9d0d5visho.min.css">
    <!--STYLES END-->  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-132758769-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-132758769-1');
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">JACE SHIM</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture">
        
        </a>
    
</header>
<div id="fb-root"></div>
<script>(function(d, s, id) {
var js, fjs = d.getElementsByTagName(s)[0];
if (d.getElementById(id)) return;
js = d.createElement(s); js.id = id;
js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.1&appId=132871117350090&autoLogAppEvents=1&colorscheme=light&order_by=time";
fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture">
                </a>
                <h4 class="sidebar-profile-name">Jace Shim</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="Categories">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="Tags">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="Archives">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/jaceshim" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/29/flutter-study-reusable-custom-card-widget/">
                            Reusable Custom Card Widget(재사용 가능한 사용자 정의 Card 위젯)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-29T16:32:35+09:00">
	
		    Jan 29, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Reusable Custom Card Widget</h1>
<h2 id="1-dog-card-위젯-만들기">1. Dog Card 위젯 만들기</h2>
<p>우리는 우리 강아지들을 display할 나이스한 위젯이 필요하다.</p>
<p>첫번째로 다음과 같은 card를 만들 것이다.<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/v1521328467/flutter_by_example/Screen_Shot_2018-03-10_at_10.28.18_AM.png" alt="card widget"></p>
<p>'dog_card.dart’파일을 신규로 생성한다.<br>
파일안에서 빈 상태의 StatefulWidget을 생성한다. 생성자에서 강아지를 가져와야 한다.<br>
당분간 이 card는 강아지의 이름만 표시 할것 이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// dog_card.dart</span><br><span class="line"></span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">import &apos;dog_model.dart&apos;;</span><br><span class="line"></span><br><span class="line">class DogCard extends StatefulWidget &#123;</span><br><span class="line">  final Dog dog;</span><br><span class="line"></span><br><span class="line">  DogCard(this.dog);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _DogCardState createState() =&gt; _DogCardState(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _DogCardState extends State&lt;DogCard&gt; &#123;</span><br><span class="line">   Dog dog;</span><br><span class="line"></span><br><span class="line">   _DogCardState(this.dog);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Text(widget.dog.name); // (역자주 : widget은 this와 동일 즉 this.dog.name으로 무관하다.)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DogCard</code>를 나타나게 <code>main.dart</code>파일의 <code>_MyHomePageState</code>클래스의 <code>build</code>메서드를 수정해 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ main.dart</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(widget.title),</span><br><span class="line">          backgroundColor: Colors.black87,</span><br><span class="line">        ),</span><br><span class="line">        body: Container(</span><br><span class="line">          child: DogCard(initialDoggos[1]), // New code</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>당연히 <code>dog_cart.dart</code>를 import해줘야 함.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.dart</span><br><span class="line"></span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">import &apos;dog_card.dart&apos;;</span><br><span class="line">import &apos;dog_model.dart&apos;;</span><br></pre></td></tr></table></figure>
<p>앱을 새로고침(refresh) 하면 바로 연결되어 있는것을(강아지의 이름) 확인 할 수 있을것이다. (역자주: 오른쪽 상단에 'Rex’라는 텍스트가 출력 된다)<br>
자 이제 Card를 만들 시간이다.</p>
<h2 id="2-dog-card-ui">2. Dog Card UI</h2>
<p>이 카드는 두가지 주요 부분이 있다. 이미지와 그 밑에 있는 실제카드.</p>
<p>첫번째로 이미지를 만들어 보자.</p>
<p>아래 getter를 <code>_DogCardState</code>클래스에 추가.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// dog_card.dart</span><br><span class="line"></span><br><span class="line">// URI를 나타내는 클래스 속성.</span><br><span class="line">// Dog클래스에서 렌더링 된다.</span><br><span class="line">String renderUrl;</span><br><span class="line"></span><br><span class="line">Widget get dogImage &#123;</span><br><span class="line">  return Container(</span><br><span class="line">      // 명시적으로 Container의 width, height를 설정할 수 있다.</span><br><span class="line">      // 그렇지 않으면 children의 공간만큼 차지한다.</span><br><span class="line">    width: 100.0,</span><br><span class="line">    height: 100.0,</span><br><span class="line">      // Decoration 속성은 컨테이너를 설정할 수 있게 해준다</span><br><span class="line">      // 이것은 BoxDecoration을 기대한다.</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">      // BoxDecorations have many possible properties.</span><br><span class="line">      // BoxDecorations은 여러가지 가능한 속성을 가지고 있다.</span><br><span class="line">      // BoxShape를 배경 이미지와 함께 사용하면 아바타 스타일로 잘라진 원circle)을 쉽게 만들 수 있다.</span><br><span class="line">      shape: BoxShape.circle,</span><br><span class="line">      image: DecorationImage(</span><br><span class="line">        // CSS의 imagesize와 동일한 속성.</span><br><span class="line">        fit: BoxFit.cover,</span><br><span class="line">        // NetworkImage위젯은 URL로 이미지를 가져 오는 위젯이다. </span><br><span class="line">        // ImageProviders (예) NetworkImage)는 이미지를 로드하거나 변경할 필요가 있을때 이상적이다.</span><br><span class="line">        // 오류를 방지하려면 Null체크를 사용하라.</span><br><span class="line">        image: NetworkImage(renderUrl ?? &apos;&apos;),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이미지를 보기 위해선 Dog클래스에 인터넷을 통해 이미지를 가져오게 해야 한다.<br>
<code>dog_cart.dart</code>안의 <code>_DogCardState</code>클래스에 다음 코드를 추가하자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// dog_card.dart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// State 클래스들은 state가 생성될때 이 메서드를 실행한다.</span><br><span class="line">// initState에선 비동기 작업을 해선 안되기 때문에 다른 메서드에서 처리되도록 연기 시킬 것이다.</span><br><span class="line">void initState() &#123;</span><br><span class="line">  super.initState();</span><br><span class="line">  renderDogPic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 우린 Dog클래스 자체적으로 이미지를 가져오길 원하지만 </span><br><span class="line">// 이것은 플러터의 기본을 설명 할 수 있는 손쉬운 방법이다. (역자주: Dog클래스가 이미지를 가져오는게 맞겠지만 플러터의 기본을 설명하는데엔 아래 방식이 더 쉽다는것으로 이해됨.)</span><br><span class="line">void renderDogPic() async &#123;</span><br><span class="line">  // 서비스 호출</span><br><span class="line">  await dog.getImageUrl();</span><br><span class="line">  // setState는 플러터에게 변경된 모든것을 다시 렌더링 하도록 지시한다.</span><br><span class="line">  // setState는 비동기가 될 수 없으므로 덮어 쓸 수 있는 변수를 사용한다.</span><br><span class="line">  setState(() &#123;</span><br><span class="line">      renderUrl = dog.imageUrl;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 우리는 렌더링 할 URL을 제대로 가져오는 아바타를 가지고 있다.<br>
카드의 겹침(overlap) 모양을 얻으러면 내장된 위젯 <code>Stack</code>을 사용해야 한다.<br>
<code>Stack</code> 위젯은 가장 자리를 기준으로 자식들을 배치한다.</p>
<p>즉 CSS <code>position</code>의 <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code> 속성과 동일하다.<br>
Stack 내에서 <code>Position</code>위젯으로 자식들을 감쌀 수 있지만 꼭 할필요는 없다.</p>
<ul>
<li>Position으로 감싸진 위젯은 웹 개발용어를 사용하자면 'document flow’의 외부에 있다.기본적으로 <code>Stack</code>위젯의 상단 모서리인 [0,0]위치에 있다.</li>
<li>감싸지지 않은 위젯은 배치되지 않는다.(positioned). 기본적으로 위젯의 열(column)으로 배치된 정상적인 'document flow’을 유지한다.</li>
</ul>
<p>다음은 stack을 시작하는 방법이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// dog_card.dart</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  // Start with a container so we can add layout and style props:</span><br><span class="line">  return Container(</span><br><span class="line">    // Arbitrary number that I decided looked good:</span><br><span class="line">    height: 115.0,</span><br><span class="line">    // A stack takes children, with a list of widgets.</span><br><span class="line">    child: Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        // position our dog image, so we can explicitly place it.</span><br><span class="line">        // We&apos;ll place it after we&apos;ve made the card.</span><br><span class="line">        Positioned(</span><br><span class="line">        child: dogImage,</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>앱을 새로고침하면 상단의 모서리에 강아지 그림이 보인다.</p>
<p><code>_DocCardState</code>의 레이아웃을 만들어 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// dog_card.dart</span><br><span class="line"></span><br><span class="line">Widget get dogCard &#123;</span><br><span class="line">  // 새로운 컨테이너</span><br><span class="line">  // height와 width는 스타일링을 위한 임의의 숫자이다.</span><br><span class="line">  return Container(</span><br><span class="line">    width: 290.0,</span><br><span class="line">    height: 115.0,</span><br><span class="line">    child: Card(</span><br><span class="line">      color: Colors.black87,</span><br><span class="line">      // padding처리를 위해 자식을 Padding위젯으로 감싼다.</span><br><span class="line">      child: Padding(</span><br><span class="line">        // padding을 제어하는 클래스를 EdgeInsets라고 한다.</span><br><span class="line">        // EdgeInsets.only 생성자는 자식의 각 side에 명시적으로 padding을 설정하는데 사용.</span><br><span class="line">        padding: const EdgeInsets.only(</span><br><span class="line">          top: 8.0,</span><br><span class="line">          bottom: 8.0,</span><br><span class="line">          left: 64.0,</span><br><span class="line">        ),</span><br><span class="line">        // Columm은 또다른 레이아웃 위젯 - stack과 비슷 - </span><br><span class="line">        // 자식들로 위젯의 목록을 취하고 위젯을 위에서 아래로 배치한다.</span><br><span class="line">        child: Column(</span><br><span class="line">          // 이들 정렬 속성은 CSS의 flexbox 속성과 정확하게 똑같이 작동한다.</span><br><span class="line">          // column의 주축은 세로축이고 `MainAxisAlignment.spaceAround` 는 </span><br><span class="line">          // CSS의 세로로 배치된 flexbox의 &apos;justify-content: space-around&apos;와 동일하다.</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(widget.dog.name,</span><br><span class="line">                // 테마는 앱의 root에서 설정한 MaterialApp widget 이다.</span><br><span class="line">                // 우리가 우리 소유의 것을 정하지 않았기 때문에 기본값을 가지고 있다.</span><br><span class="line">                // 쉽게 변경 가능한 앱 차원의 일관된 스타일을 유지 하는데 탁월하다.</span><br><span class="line">                style: Theme.of(context).textTheme.headline),</span><br><span class="line">            Text(widget.dog.location,</span><br><span class="line">                style: Theme.of(context).textTheme.subhead),</span><br><span class="line">            Row(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Icon(</span><br><span class="line">                  Icons.star,</span><br><span class="line">                ),</span><br><span class="line">                Text(&apos;: $&#123;widget.dog.rating&#125; / 10&apos;)</span><br><span class="line">              ],</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>거의다 왔다!!, DogCard UI를 완성하기 위해 한 가지 더 할일이 있다.<br>
build 메서드의 기본 위젯에 조금 더 스타일을 추가해 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// dog_card.dart</span><br><span class="line"></span><br><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Padding(</span><br><span class="line">    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),</span><br><span class="line">    child: Container(</span><br><span class="line">      height: 115.0,</span><br><span class="line">      child: Stack(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Positioned(</span><br><span class="line">            left: 50.0,</span><br><span class="line">            child: dogCard,</span><br><span class="line">          ),</span><br><span class="line">          Positioned(top: 7.5, child: dogImage),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/29/flutter-study-reusable-custom-card-widget/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/29/flutter-study-reusable-custom-card-widget/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/29/flutter-study-data-model-and-http/">
                            Data Model &amp; HTTP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-29T14:33:33+09:00">
	
		    Jan 29, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<p>#Data Model &amp; HTTP</p>
<h2 id="1-get-to-a-clean-slate">1. Get to a Clean Slate</h2>
<p>모든 플러터앱은 <code>main.dart</code>로 시작한다. Counter앱 관련한 부분을 제거하면 다음과 같다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// main.dart</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    /// MaterialApp is the base Widget for your Flutter Application</span><br><span class="line">    /// Gives us access to routing, context, and meta info functionality.</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;We Rate Dogs&apos;,</span><br><span class="line">      // Make all our text default to white</span><br><span class="line">      // and backgrounds default to dark</span><br><span class="line">      theme: ThemeData(brightness: Brightness.dark),</span><br><span class="line">      home: MyHomePage(title: &apos;We Rate Dogs&apos;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  final String title;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">    @override</span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        /// Scaffold is the base for a page.</span><br><span class="line">        /// It gives an AppBar for the top,</span><br><span class="line">        /// Space for the main body, bottom navigation, and more.</span><br><span class="line">        return Scaffold(</span><br><span class="line">            /// App bar has a ton of functionality, but for now lets</span><br><span class="line">            /// just give it a color and a title.</span><br><span class="line">            appBar: AppBar(</span><br><span class="line">                /// Access this widgets properties with &apos;widget&apos;</span><br><span class="line">                title: Text(widget.title),</span><br><span class="line">                backgroundColor: Colors.black87,</span><br><span class="line">            ),</span><br><span class="line">            /// Container is a convenience widget that lets us style it&apos;s</span><br><span class="line">            /// children. It doesn&apos;t take up any space itself, so it</span><br><span class="line">            /// can be used as a placeholder in your code.</span><br><span class="line">            body: Container(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-dog-model-클래스-생성">2. Dog Model 클래스 생성.</h2>
<p>data model을 위해 Dog이라는 일반 Dart클래스를 만든다.</p>
<p>첫번째로 <code>dog_model.dart</code>라는 파일을 <code>lib</code> 폴더안에 생성한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- lib</span><br><span class="line">  -dog_model.dart</span><br><span class="line">  -main.dart</span><br></pre></td></tr></table></figure>
<p>저 파일에서 몇 가지 속성을 가진 수퍼 기본 클래스 (super basic class)를 만들 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final String location;</span><br><span class="line">  final String description;</span><br><span class="line">  String imageUrl;</span><br><span class="line"></span><br><span class="line">  // 모든 강아지는 10점부터 출발한다. 왜냐면 다 좋은 강아지니깐~</span><br><span class="line">  int rating = 10;</span><br><span class="line"></span><br><span class="line">  Dog(this.name, this.location, this.description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-강아지-사진-얻기">3. 강아지 사진 얻기</h2>
<p>우리는 강아지 이미지를 생성하기 위해 API키 또는 다른 어떠한것도 필요없는 매우 간단한 API를 사용할 것이다.<br>
강아지 이미지를 random 찾아주는 <a href="https://dog.ceo/" target="_blank" rel="noopener">dog.ceo</a>를 이용할 것이다.</p>
<p><code>Dog</code>클래스에 다음 메서드를 추가하자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// dog_model.dart</span><br><span class="line"></span><br><span class="line">Future getImageUrl() async &#123;</span><br><span class="line">  // Null check so our app isn&apos;t doing extra work.</span><br><span class="line">  // If there&apos;s already an image, we don&apos;t need to get one.</span><br><span class="line">  if (imageUrl != null) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This is how http calls are done in flutter:</span><br><span class="line">  HttpClient http = HttpClient();</span><br><span class="line">  try &#123;</span><br><span class="line">    // Use darts Uri builder</span><br><span class="line">    var uri = Uri.http(&apos;dog.ceo&apos;, &apos;/api/breeds/image/random&apos;);</span><br><span class="line">    var request = await http.getUrl(uri);</span><br><span class="line">    var response = await request.close();</span><br><span class="line">    var responseBody = await response.transform(utf8.decoder).join();</span><br><span class="line">    // The dog.ceo API returns a JSON object with a property</span><br><span class="line">    // called &apos;message&apos;, which actually is the URL.</span><br><span class="line">    imageUrl = json.decode(responseBody)[&apos;message&apos;];</span><br><span class="line">  &#125; catch (exception) &#123;</span><br><span class="line">    print(exception);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>주의</em>: 위 코드를 추가 하려면 두개의 Dart패키지를 import해야 함.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:convert&apos;; // json string 변환을 위함.</span><br><span class="line">import &apos;dart:io&apos;; // HttpClient를 위함.</span><br></pre></td></tr></table></figure>
<h2 id="4-new-dog-class로-약간의-sample-데이터-생성">4. new Dog class로 약간의 sample 데이터 생성.</h2>
<p><code>main.dart</code>에서 강아지 몇마리를 생성해 보자.</p>
<p>첫번째로 <code>dog_model.dart</code>를 import하자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.dart</span><br><span class="line"></span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">import &apos;dog_model.dart&apos;;</span><br></pre></td></tr></table></figure>
<p>그리고 약간의 강아지를 추가.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// main.dart in the State class</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  List&lt;Dog&gt; initialDoggos = []</span><br><span class="line">    ..add(Dog(&apos;Ruby&apos;, &apos;Portland, OR, USA&apos;,</span><br><span class="line">        &apos;Ruby is a very good girl. Yes: Fetch, loungin\&apos;. No: Dogs who get on furniture.&apos;))</span><br><span class="line">    ..add(Dog(&apos;Rex&apos;, &apos;Seattle, WA, USA&apos;, &apos;Best in Show 1999&apos;))</span><br><span class="line">    ..add(Dog(&apos;Rod Stewart&apos;, &apos;Prague, CZ&apos;,</span><br><span class="line">        &apos;Star good boy on international snooze team.&apos;))</span><br><span class="line">    ..add(Dog(&apos;Herbert&apos;, &apos;Dallas, TX, USA&apos;, &apos;A Very Good Boy&apos;))</span><br><span class="line">    ..add(Dog(&apos;Buddy&apos;, &apos;North Pole, Earth&apos;, &apos;Self proclaimed human lover.&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/29/flutter-study-data-model-and-http/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/29/flutter-study-data-model-and-http/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/29/flutter-study-basic-dogs-app-setup/">
                            Basic Dogs App Setup
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-29T13:56:45+09:00">
	
		    Jan 29, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Basic Dogs App Setup ( 기본 강아지 앱 설정)</h1>
<h2 id="이것은-굉장한-프레임워크다">이것은 굉장한 프레임워크다.</h2>
<p>이 기본 앱 튜토리얼에서는 2012년 We Rate Dogs vs Brant 대결을 통해 역대 최고의 Twitter대화에서 영감을 받아 매우 간단하고 순수한 플러터 앱을 만들 것이다. (역자주: 2010년 트위터의 WeRateDogs라는 계정이 애완견 사진을 올리고 사용자들끼리 평가와 대화를 하는 트윗에   Brant라는 계정이 딴지를 걸기 시작한 사건으로 제가 확인은 안해봤지만 단일 대화 주제로는 트위터 설립이래 최고의 대화가 오갔다고 함.)</p>
<p>여기서 우리는 추가 package를 가져오지(사용하지) 않을 것이며 아키텍쳐나 state관리에 대해 생각하지 않을 것이다.</p>
<p>이 작업이 끝날 때쯤이면, 플러터가 우리에게 얼마나 많은 것을 주었는지에 대해 상당히 놀랄것이다. 그리고 우리는 거의 모든 것을 커버하지 않을 것이다.(역자주: 플러터가 제공하는 수 많은 기능에 대해 다루진 않겠다는 의미 인듯.)</p>
<p>우리가 무엇을 만들지 보자.<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/c_scale,w_300/v1520699901/flutter_by_example/new_dog.gif" alt="dogs1"> <img src="https://res.cloudinary.com/ericwindmill/image/upload/c_scale,w_300/v1520699902/flutter_by_example/good_dogs.gif" alt="dogs2"></p>
<p><a href="https://github.com/ericwindmill/flutter_by_example_apps" target="_blank" rel="noopener">완성된 코드 링크</a></p>
<p>우리는 새로운 앱에서 시작할 것이다. 일단 <a href="https://flutter.io/docs/get-started/install" target="_blank" rel="noopener">플러터 설치 및 설정을 하고 난 후</a> (설치 및 설정 되어 있다면 pass) 새로운 앱을 만든다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter create basic_flutter_app</span><br><span class="line">cd basic_flutter_app</span><br><span class="line">flutter run</span><br></pre></td></tr></table></figure>
<p>또는 <a href="https://github.com/ericwindmill/flutter_by_example_apps" target="_blank" rel="noopener">Github</a>에서 이미 생성된 app을 clone받아도 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ericwindmill/flutter_by_example_apps.git</span><br><span class="line">cd flutter_by_example_apps/blank_flutter_app</span><br><span class="line">flutter packages get</span><br><span class="line">flutter run</span><br></pre></td></tr></table></figure>
<p>이것은 새롭고, 빈(?) 플러터 앱을 제공한다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/29/flutter-study-basic-dogs-app-setup/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/29/flutter-study-basic-dogs-app-setup/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/28/flutter-study-stateful-widget-lifecycle/">
                            Stateful Widget Lifecycle(생명주기)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-28T20:06:32+09:00">
	
		    Jan 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Stateful Widget Lifecycle(생명주기)</h1>
<p>플러터가 StatefulWidget을 만들 때, State객체를 만든다. 이 개체는 해당 위젯의 모든 가변 상태가 유지 되는 곳이다.</p>
<p>state의 개념은 두 가지로 정의 된다:</p>
<ol>
<li>위젯이 사용하는 데이터는 변경 될 수 있다.</li>
<li>위젯이 빌드 될때 데이터를 동시에(synchronously) 읽을 수 없다. (모든 state는 build 메서드가 호출 될때 까지 설정 되어야 한다.)</li>
</ol>
<p>라이프 싸이클은 다음과 같은 간단한 단계를 포함하고 있다.</p>
<ul>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#1-createstate" target="_blank" rel="noopener">createState()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#2-mounted-is-true" target="_blank" rel="noopener">mounted == true</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#3-initstate" target="_blank" rel="noopener">initState()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#4-didChangeDependencies" target="_blank" rel="noopener">didChangeDependencies()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#5-build" target="_blank" rel="noopener">build()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#6-didupdatewidget" target="_blank" rel="noopener">didUpdateWidget()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#7-setstate" target="_blank" rel="noopener">setState()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#8-deactivate" target="_blank" rel="noopener">deactivate()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#9-dispose" target="_blank" rel="noopener">dispose()</a></li>
<li><a href="https://flutterbyexample.com/stateful-widget-lifecycle#10-mounted-is-false" target="_blank" rel="noopener">mounted == false</a></li>
</ul>
<h2 id="statefulwidget-과-state-클래스는-별도로-분리되었는가">StatefulWidget 과 State 클래스는 별도로 분리되었는가?</h2>
<p>한마디로 말하면 성능이다.</p>
<p><code>State</code>객체는 오래 유지되지만 <code>StatefulWidgets</code>(및 모든 <code>Widget</code>의 서브클래스)는 구성이 변경 될때마다 폐기하고 다시 작성된다. 플러터가 변경 가능한(mutable) 위젯을 다시 작성하는것은 매우 저렴하다.</p>
<p><code>State</code>는 재구축(rebuild)할때 마다 폐기되지 않으므로 비용 큰 계산을 피할 수 있으며 프레임별로(frame)로 프레임이 재구성 될때 마다 state속성, getter, setter등에서 가져온다.</p>
<p>중요한것은 이것이 플러터 애니메이션을 존재하도록 한다는 것이다. <code>State</code>는 폐기되지 않으므로 데이터 변경에 대한 응답으로 필요할 때 언제든지 위젯을 재 구성 할 수 있다.</p>
<h2 id="1-createstate">1. createState()</h2>
<p>플러터가 <a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noopener"><code>StatefulWidget</code></a>을 빌드하도록 지시하면 즉시 [<code>createState()</code>]가 호출된다. 이 메서드는 반드시 존재해야 한다.(역자주: createState()를 말함) <code>StatefulWidget</code>은 이것보다 더 복잡할 필요가 거의 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; new _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-mounted-is-true">2. mounted is true</h2>
<p><a href="https://docs.flutter.io/flutter/widgets/StatefulWidget/createState.html" target="_blank" rel="noopener">createState</a>가 state클래스를 생성하면 <code>buildContext</code>는 state에 할당 된다.<br>
BuildContext는 위젯이 배치된 위젯 트리의 위치를 단순화 한 것이다.</p>
<p>모든 위젯은 <code>bool</code>형식의 <code>this.mounted</code> 속성을 가지고 있다. <code>buildContext</code>가 할당되면 <code>true</code>를 리턴한다. 위젯이 unmounted상태일때 <code>setState</code>를 호출하면 error가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tip: 이 속성은 state에 `setState()`를 호출할때 유용하지만 해당 메서드가 언제, 얼마나 자주 호출 되는지는 명확하지 않다. 아마도 stream이 업데이트에 대한 응답으로 호출되는것 같다. `if (mounted) &#123;...` 를 사용하여 `setState()`호출전에 State가 존재하는지 확인 할 수 있디.</span><br></pre></td></tr></table></figure>
<h2 id="3-initstate">3. initState()</h2>
<p>위젯이 생성될때 처음으로 호출되는 메서드 이다.(물론 class생성자 다음 입죠~)<br>
<a href="https://docs.flutter.io/flutter/widgets/State/initState.html" target="_blank" rel="noopener"><code>initState</code></a>는 오직 한번 만 호출 된다. 또한 반드시 <code>super.initState()</code>를 호출해야 한다.</p>
<p>initState에서 실행되면 좋은 것들</p>
<ol>
<li>생성된 위젯 인스턴스의 BuildContext에 의존적인 것들의 데이터 초기화</li>
<li>동일 위젯트리내에 부모위젯에 의존하는 속성 초기화</li>
<li>Stream 구독, 알림변경, 또는 위젯의 데이터를 변경할 수 있는 다른 객체 핸들링.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">initState() &#123;</span><br><span class="line">  // 부모의 initState호출</span><br><span class="line">  super.initState();</span><br><span class="line">  // 이 클래스애 리스너 추가</span><br><span class="line">  cartItemStream.listen((data) &#123;</span><br><span class="line">    _updateWidget(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-didchangedependencies">4. didChangeDependencies()</h2>
<p><a href="https://docs.flutter.io/flutter/widgets/State/didChangeDependencies.html" target="_blank" rel="noopener"><code>didChangeDependencies</code></a> 메서드는 위젯이 최초 생성될때 <code>initState</code> 다음에 바로 호출 된다.<br>
또한 위젯이 의존하는 데이터의 객체가 호출될때마다 호출된다. 예를 들면 업데이트되는 위젯을 상속한 경우.<br>
공식문서 또한 상속한 위젯이 업데이트 될때 네트워크 호출(또는 다른 비용이 큰 액션)(역자주: API호출)이 필요한 경우 유용하다고 함.</p>
<h2 id="5-build">5. build()</h2>
<p>이 메서드는 자주 호출된다(fps + render로 생각하세요.). 필수이며 재정의 대상(<code>@override</code>)이고 반드시 <a href="https://docs.flutter.io/flutter/widgets/Widget-class.html" target="_blank" rel="noopener">Widget</a>을 리턴해야 한다.</p>
<p>플러터의 모든 gui는 <a href="https://docs.flutter.io/flutter/widgets/Padding-class.html" target="_blank" rel="noopener">Padding</a>, <a href="https://docs.flutter.io/flutter/widgets/Center-class.html" target="_blank" rel="noopener">Center</a> 조차도 child 또는 children을 가진 위젯 이라는것을 기억하라.</p>
<h2 id="6-didupdatewidget-widget-oldwidget">6. didUpdateWidget(Widget oldWidget)</h2>
<p><a href="https://docs.flutter.io/flutter/widgets/State/didUpdateWidget.html" target="_blank" rel="noopener">didUpdateWidget()</a>는 부모 위젯이 변경되어 이 위젯을 재 구성해야 하는 경우(다은 데이터를 제공 해야하기 때문)</p>
<p>이것은 플러터가 오래동안 유지 되는 <code>state</code>를 다시 사용하기 때문이다. 이 경우 <code>initState()</code>에서 처럼 읿부 데이터를 다시 초기화 해야 한다.</p>
<p><code>build()</code> 메서드가 Stream이나 변경 가능한 데이터에 의존적인경우 이전 객체에서 구독을 취소하고 <code>didUpdateWidget()</code>에서 새로운 인스턴스에 다시 구독 해야함.</p>
<p><em>tip:</em> 이 메서드는 기본적으로 위젯의 상태와 관련된 위젯을 재 구성해야 하는 경우 <code>initState()</code>을 대치한다.</p>
<p>플러터는 항상 이 메서드 수행 후에 <code>build()</code>메서드 호출 하므로, <code>setState()</code> 이후 모든 추가 호출은 불필요 하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didUpdateWidget(Widget oldWidget) &#123;</span><br><span class="line">  if (oldWidget.importantProperty != widget.importantProperty) &#123;</span><br><span class="line">    _init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-setstate">7. setState()</h2>
<p><a href="https://docs.flutter.io/flutter/widgets/State/setState.html" target="_blank" rel="noopener">setState()</a> 메서드는 플러터 프레임워크 자체적, 또는 개발자로 부터 자주 호출된다.<br>
'데이터가 변경되었음’을 프레임워크에 알리는데 사용되며 <code>build context</code>의 위젯을 다시 빌드하게 한다.<br>
<code>setState()</code>는 비동기적이 않은 callback을 사용한다.(역자주: callback으로 비동기를 사용할 수 없다는 말임).</p>
<h2 id="8-deactivate">8. deactivate()</h2>
<p>이 메서드는 거의 사용되지 않는다.<br>
<a href="https://docs.flutter.io/flutter/widgets/State/deactivate.html" target="_blank" rel="noopener">deactivate()</a>는 tree에서 <code>State</code>가 제거 될때 호출 된다. 그러나 현재 프레임 변경이 완료되기 전에 다시 삽입 될 수 있다. 이 메서드는 <code>State</code>객체가 tree의 한 지점에서 다른 지점으로 이동 할 수 있기 때문에 기본적으로 존재한다.<br>
필요에 따라 자주 호출 할 수 있는 이유는 다시 그리(repainting)는데 소용되는 비용이 저렴하기 때문이다. :-)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void updateProfile(String name) &#123;</span><br><span class="line"> setState(() =&gt; this.name = name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-dispose">9. dispose()</h2>
<p><a href="https://docs.flutter.io/flutter/widgets/State/dispose.html" target="_blank" rel="noopener">dispost()</a>는 <code>State</code>객체가 영구히 제거 된다.</p>
<h2 id="10-mounted-is-false">10. mounted is false</h2>
<p>이 상태에서 <code>state</code> 객체는 결코 다시 mount되지 않으며, <code>setState()</code>가 호출되면 에러가 발생한다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/28/flutter-study-stateful-widget-lifecycle/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/28/flutter-study-stateful-widget-lifecycle/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/28/flutter-study-dissecting-the-counter-app/">
                            Dissecting the Counter App (카운터앱 해부)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-28T14:07:42+09:00">
	
		    Jan 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Dissecting the Counter App (카운터앱 해부)</h1>
<p>‘Hello World’ 플러터 앱은 다음과 같은 간단한 카운터 이다.<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/c_scale,w_300/v1518377792/flutter_by_example/Simulator_Screen_Shot_-_iPhone_X_-_2018-02-11_at_11.34.36.png" alt="counter app1"> <img src="https://res.cloudinary.com/ericwindmill/image/upload/c_scale,w_300/v1518377793/flutter_by_example/Simulator_Screen_Shot_-_iPhone_X_-_2018-02-11_at_10.34.27.png" alt="counter app2"></p>
<h2 id="1-터미널에서-다음-명령을-실행">1. 터미널에서 다음 명령을 실행.</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_app</span><br><span class="line">cd my_app</span><br></pre></td></tr></table></figure>
<p>에디터로 project을 open.</p>
<h2 id="2-ide-또는-터미널을-사용하여-앱을-실행">2. IDE 또는 터미널을 사용하여 앱을 실행.</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure>
<p><em>IntelliJ:</em> IDE상단에는 다음과 같은 모양의 도구 모음이 있다.(나의 경우 테마를 설치해서 아마도 여러분의 아이콘과는 다를 것이다.)<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/v1518916683/flutter_by_example/Screen_Shot_2018-02-17_at_5.17.47_PM.png" alt="ide toolbar"></p>
<ol>
<li>toolbar 이미지의  iPhoneX 라고 씌여진 부분이 비어 있는 경우 iOS 시뮬레이터 열기(open iOS Simulator)를 선택.</li>
<li>앱이 실행되면 'play’버튼을 클릭해서 앱을 실행. <em>주의</em> 여러분은 'debug’버튼을 debug mode로 실행할 수 있다. 나는 일반적으로 개발할땐 항상 debug mode로 실행한다. debug mode 는 play버튼 실행시와 동일하지만 'breakpint’와 'inspector’를 허용한다.<br>
앱이 실행되면:</li>
</ol>
<h2 id="3-앱의-오른쪽-하단의-버튼을-클릭">3. 앱의 오른쪽 하단의 ‘+’ 버튼을 클릭.</h2>
<p>그것이 유일한 기능이고 카운터가 변경되는것을 확인해 보자.</p>
<p>무슨일이 일어났나? 버튼에는 카운터를 나타내는 앱 상태 변수를 증가 시시는 이벤트 리스너가 있다.<br>
플러터는 해당 상태를 변경할 때마다 해당 상태에 의존하는 위젯(이 경우 number)를 다시 출력해야 함을 알고 있다.</p>
<h2 id="4-코드-이해하기">4. 코드 이해하기</h2>
<p>첫번째로 디렉토리 구조(directory structure)상에서 무슨 작업을 하는지 알아보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_app</span><br><span class="line">  |- android</span><br><span class="line">  |  ... a bunch of junk</span><br><span class="line">  |- ios</span><br><span class="line">  |  ... a bunch of junk</span><br><span class="line">  |- lib</span><br><span class="line">  |  main.dart</span><br><span class="line">  |- test</span><br><span class="line">  pubspec.lock</span><br><span class="line">  pubspec.yaml</span><br><span class="line">  README.md</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>개발시간의 99%는 <code>lib</code>폴더와 <code>pubspec.yaml</code> 파일에만 관심이 있으며, 여기서 프로젝트 의존성을 나열 할 수 있다.<br>
<code>lib</code>폴더는 앱을 빌드하는 곳이며, <code>my_app</code>프로젝트에는 <code>main.dart</code>만 존재한다.<br>
<code>main.dart</code>는 반드시 존재해야 하며, 반드시 <code>lib</code>폴더 root에 존재해야 한다. 이 파일은 다트와 플러터가 진입점으로 인식하는 파일 이다.</p>
<p>파일의 코드를 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// import the Flutter sdk</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">// 모든 다트 프로그램은 무조건 main()함수가 있어야 한다.</span><br><span class="line">// 이 함수는 본질적으로 자바스크립트 Document.ready()이며, 반드시 있어야 한다.</span><br><span class="line">// 이것은 다트 코드의 진입점이다.</span><br><span class="line">// runApp은 앱을 실행하는 플러터 함수 이다.</span><br><span class="line">// 이것은(runApp함수) 위젯을 인수로 취한다.</span><br><span class="line">void main() =&gt; runApp(new MyApp());</span><br><span class="line"></span><br><span class="line">// 모든것이 위젯이다.</span><br><span class="line">// 전체앱의 root를 포함:</span><br><span class="line">class MyApp extends Stateless Widget &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">// 주의: MyApp은 임의의 이름 이다.</span><br></pre></td></tr></table></figure>
<h2 id="stateless-and-statefulwidgets">Stateless and StatefulWidgets</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">// Stateless 위젯은 어떠한 상태변경도 하지 않는다.</span><br><span class="line">// 여러분 어플리케이션의 Root</span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // Build method</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // MaterialApp은 플러터의 기본내장된 위젯으로 다양한 스타일을 제공한다.</span><br><span class="line">    // MaterialApp의 가장 중요한 아규먼트는 title과 home이다.</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      // Arguments that Material App is looking for.</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      theme: new ThemeData(</span><br><span class="line">        // 이것은 앱의 기본색상을 Blue로 설정한다.</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      // MyHomePage은 개발자인 여러분이 이름붙인 또 다른 임의의 위젯이다.</span><br><span class="line">      home: new MyHomePage(title: &apos;Flutter Home Demo Page&apos;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 이 위젯은 카운터의 상태를 관리하고 있으므로 Statefull임.</span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line">  // 제목으로 전달되고 있어 위에서 볼수 있다.</span><br><span class="line">  final String title; // =&gt; Flutter Home Demo Page</span><br><span class="line"></span><br><span class="line">   // Stateful 위젯은 build메서드를 가지고 있지 않다.</span><br><span class="line">   // createState() 메서드를 가지고 있고 State를 생성하면 플러터 State클래스를 상속한 클래스가 리턴된다.</span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; new _MyHomePageState();</span><br><span class="line"></span><br><span class="line">  // Stateful Widgets are rarely more complicated than this.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 이것은 MyHomePage가 생성한 state이다.</span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  int _counter = 0;</span><br><span class="line"></span><br><span class="line">  // flutter counterApp sample의 comment가 내가 설명하는것보다 더 나아서 남겨둠.</span><br><span class="line">  void _incrementCounter() &#123;</span><br><span class="line">    // 플러터 메서드에 내장</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      // setState의 호출이 발생하면 플러터 프레임워크에 뭔가 상태 변경이 있음을 알려주며, 이로 인해 아래의</span><br><span class="line">      // build 메서드가 재실행되어 디스플레이에 업데이트된 값이 반영 될 수 있다.</span><br><span class="line">      // setState()를 호출하지 않고 _counter의 값을 변경하면 build메서드가 다시 호출되지 않으므로 아무 일도 일어나지 않을 것이다.</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // 이 메서드는 setState가 호출되면 매번 재 실행된다. (예를 들어 위의 _incrementCounter메서드가 완료되면)</span><br><span class="line"></span><br><span class="line">    // Scaffold는 우리에게 표준 모바일 앱 레이아웃을 제공하는 앱의 또 다른 빌드다.</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      //앱의 상단에 있는 bar</span><br><span class="line">      appBar: new AppBar(</span><br><span class="line">        // State클래는 widget.someProperty 형식으로 부모 클래스의 프로퍼티를 액세스 한다.  </span><br><span class="line">        // StatefulWidgets와 해당 StateClasses를 단일 위젯으로 생각하는 것이 더 쉽다.</span><br><span class="line">        title: new Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: new Center(</span><br><span class="line">        // Center는 layout위젯이다. 이것은 단일 자식을 취하며 부모의 중간(한가운데)에 위치 시킨다.</span><br><span class="line">        child: new Column(</span><br><span class="line">          // Column 또한 layout위젯이다. 이것은 다수의 자식을 수직으로 정렬한다. </span><br><span class="line">          // 기본적으로 자식들을 수평으로 맞추기 위해 크기를 정하고 부모의 사이즈만큼 커진다.(역자주: 부모의 사이즈를 자식수로 나눠서 사이즈가 정해진다.)</span><br><span class="line">          //</span><br><span class="line">          // Column은 크기를 어떻게 해야 하고 자식들을 어떻게 위치시키는지를 제어하는 다양한 속성을 가지고 있다.</span><br><span class="line">          // 여기서 우리는 mainAxisAlignment를 사용하여 자식들을 세로 중앙에 위치 시킨다. </span><br><span class="line">          // 여기서 주축은 세로축이다, Columns이 수직이기 때문이다.(교차축은 수평이 된다)</span><br><span class="line">          //</span><br><span class="line">          // mainAxisAlignment와 crossAxisAlignment는 CSS의 Flexbox또는 Grid를 사용해봤다면 매우 익숙할 것이다.</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            new Text(</span><br><span class="line">              &apos;You have pushed the button this many times:&apos;,</span><br><span class="line">            ),</span><br><span class="line">            new Text(</span><br><span class="line">              // Text는 첫번째 아규먼트 String을 이용한다.</span><br><span class="line">              // 우리는 counter의 값을 삽입 String으로 전달한다.</span><br><span class="line">              &apos;$_counter&apos;,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      // Floating actino버튼은 특수 버튼임.</span><br><span class="line">      floatingActionButton: new FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: &apos;Increment&apos;,</span><br><span class="line">        child: new Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="the-widget-tree">The Widget Tree</h2>
<p>이 모든 클래스의 중첩이 혼란 스러울 경우 위젯 시각화된 트리가 도움이 될 것이다. 다음 그림은 여러분의 현재 Counter 어플리케이션의 위젯 트리이다. 중첩된 위젯은 단순히 모든 JS기능이 내장된 중첩된 React컴포넌트 또는 HTML웹 구성요소로 생각할 수 있다.</p>
<p><img src="https://res.cloudinary.com/ericwindmill/image/upload/v1518974500/flutter_by_example/simple_tree.png" alt="widget tree"></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/28/flutter-study-dissecting-the-counter-app/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/28/flutter-study-dissecting-the-counter-app/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/25/flutter-study-buildcontext-class/">
                            Flutter Buildcontext Class
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-25T14:05:52+09:00">
	
		    Jan 25, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>BuildContext Class</h1>
<p>모든 플러터 위젯은 <code>BuildContext</code> 인수(매개변수)가 포함된 <code>@override build()</code> 메소드를 가지고 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CartItemWidget extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure>
<h2 id="why-buildcontext">why BuildContext</h2>
<p><code>BuildContext</code>를 간단히 설명하자면 다음과 같다:</p>
<ul>
<li>위젯tree에서 위젯의 위치.</li>
<li>중첩되어 감싸진 위젯의 위젯. <code>&lt;div &lt;div&gt; .html&gt;</code>와 같은…</li>
<li>qt와 비슷한 부모 객체들(parent objects in qt and alike) (역자주: 여기서 말하는 qt가 뭔지 모르겠음.)</li>
<li>플러터에선 최종 <code>build.call()</code> 까지 모든게 위젯임.</li>
<li>마지막으로 위젯이 &quot;stuff&quot;를 리턴 할때 까지의 행(row) 차원(dimentions).</li>
</ul>
<p>이해 해야할 중요한 개념은:</p>
<ol>
<li>모든 위젯은 고유의 <code>build()</code> 메소드와 <code>context</code>를 가지고 있다.</li>
<li><code>BuildContext</code>는 <code>build()</code> 메소드에 의해 리턴된 위젯의 부모다.</li>
</ol>
<p>즉, 위젯의 <code>build()</code> 메소드를 호출하는 위젯의<code>BuildContext</code>와 <code>build()</code>를 통해 리턴되는 위젯의 <code>BuildContext</code>는 동일하지 않다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  _MyHomePageState() &#123;</span><br><span class="line">    print(context.hashCode);</span><br><span class="line">    // prints 2011</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      appBar: new AppBar(</span><br><span class="line">        title: new Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: new Container(),</span><br><span class="line">      floatingActionButton:</span><br><span class="line">          new FloatingActionButton(onPressed: () =&gt; print(context.hashCode)),</span><br><span class="line">          // prints 63</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(역자주 : 위 코드에서 두개의 print 메소드 실행시 전달된 <code>BuildContext</code>의 hashCode값이 다르다는것은 서로 다른 객체라는걸 알수 있다.)</p>
<p><em>그래서 뭘 얘기 하려는 거요?</em><br>
이거 큰거 하나 잡았다!(큰거 하나 알게되었다는 뜻인듯…) ;-)</p>
<ul>
<li>잘못된 <code>build()</code>를 참조하기 쉽다.</li>
<li>그리고 그것은 <code>context</code>. (역자주: 잘못된 build()의 리턴값인 BuildContext를 참조하여 문제를 일으 킬수 있다정도로 이해됨 )</li>
<li>이것은 특히 <code>of()</code> 메소드를 사용할때 예기치 않은 상황이 발생 할 수 있다.</li>
</ul>
<h2 id="the-of-method">The ‘of()’ Method</h2>
<p>플러터에선 모든게 위젯이므로,(역자주: 이제 집겨다!!) 어떤 경우 다른 위젯을 참조하기 위해 위젯 트리를 위/아래로 훑기도 한다. 이것은 일부 기능에선 필수이다.</p>
<p>특히 상속(<code>inherited</code>)된 위젯의 상태를 사용하려는 위젯은 상속한 위젯을 참조 할 수 있어야 한다. 이것은 일반적으로 <code>of()</code> 메소드의 형식으로 제공된다.</p>
<p>예 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(context) &#123;</span><br><span class="line">  return new Text(&apos;Hello, World&apos;,</span><br><span class="line">    style: new TextStyle(color: Theme.of(context).primaryColor),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>of()</code> 메소드는 내부적으로 <code>Theme</code> 유형의 다음 상위 위젯에 대한 트리를 찾고 기본 색상 속성을 가져온다. 프레임워크는 이 build context와 관련한 트리를 알고 있으므로 올바른 <code>Theme</code>개체를 찾을 수 있다.</p>
<h2 id="the-gotcha">The Gotcha</h2>
<p>플러터는 <code>scaffold</code>(비계)를 통해 우리에게 다음과 같은 문제를 해결 할 수 있는 좋은 방법을 제공한다.</p>
<p><code>snackbar</code>와 같은 일부 위젯을 만들때, 가장 근접한 <code>Scafold</code> 컨텍스트를 얻어서 플러터가 <code>snackbar</code>를 그리는 방법을 알게 해야 한다. <code>Scafold</code>는 실제 우리가 <code>snackbar</code>를 디스플레이 할 수 있는 위젲이기 때문이다.</p>
<p><code>아래 코드는 작동하지 않는다.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">        appBar: new AppBar(</span><br><span class="line">          title: new Text(widget.title),</span><br><span class="line">        ),</span><br><span class="line">        body: new Container(),</span><br><span class="line">        /// 이 컨텍스트는 Scaffold가 없음</span><br><span class="line">        /// 왜냐면 빌드로 전달된 컨텍스트는 현재 트리의 상위 위젯이고</span><br><span class="line">        /// 상위 위젯에에는 Scaffold가 없기 때문임.</span><br><span class="line">        ///</span><br><span class="line">        /// 이것은 에러를 던질것이다:</span><br><span class="line">        /// &apos;Scaffold.of() 호출시 전달된 context에는 Scaffold가 포함되어 있지 않기 때문에&apos;</span><br><span class="line">        floatingActionButton: new FloatingActionButton(onPressed: () &#123;</span><br><span class="line">          Scaffold.of(context).showSnackBar(</span><br><span class="line">                new SnackBar(</span><br><span class="line">                  content: new Text(&apos;SnackBar&apos;),</span><br><span class="line">                ),</span><br><span class="line">              );</span><br><span class="line">        &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="builder-methods">Builder Methods</h2>
<p><code>Builder</code>는 <code>closure</code>를 사용하여 하위 위젯을 작성하는 위젯이다. laymans(역자주: In laymans - 평신도 라는 단어인데 어떻게 해석할지 모르겠음)에서는 build 메소드로 리턴되는 자식들에게 직접 컨텍스트를 전달하는데 사용 할 수 있다.</p>
<p>위의 예제를 사용하면(역자주: 위에 오류난 코드를 사용):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      appBar: new AppBar(</span><br><span class="line">        title: new Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: new Container(),</span><br><span class="line">      /// Builders를 사용하면 현재 build메소드에서 컨텍스트를 전달할 수 있다.</span><br><span class="line">      /// 이 build 메소드에서 리턴되는 하위 위젯에 직접 전달.</span><br><span class="line">      // &apos;builder&apos; 속성은 모든 위젯에서 build메소드로 정확하게 처리 할 수 있는 callback를 허용.</span><br><span class="line">      floatingActionButton: new Builder(builder: (context) &#123;</span><br><span class="line">        return new FloatingActionButton(onPressed: () &#123;</span><br><span class="line">          Scaffold.of(context).showSnackBar(</span><br><span class="line">                new SnackBar(</span><br><span class="line">                  backgroundColor: Colors.blue,</span><br><span class="line">                  content: new Text(&apos;SnackBar&apos;),</span><br><span class="line">                ),</span><br><span class="line">              );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><em>tip</em>: 여러분은 단순히 build메소드를 작게 만들고 더 상위 위젯에서 Scaffold를 리턴하여 이 문제를 해결 할 수도 있다. 의심 스러운 경우 더 작은 리턴 method를 고수하라!</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/25/flutter-study-buildcontext-class/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/25/flutter-study-buildcontext-class/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/24/flutter-study-widgets/">
                            Flutter Widgets
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-24T17:37:16+09:00">
	
		    Jan 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Flutter Widgets</h1>
<p>어떤걸 다루나?</p>
<ul>
<li><a href="https://flutterbyexample.com/flutter-widgets#whats-a-widget" target="_blank" rel="noopener">위젯이 무엇인지?</a></li>
<li><a href="https://flutterbyexample.com/flutter-widgets#stateless-and-statefulwidgets" target="_blank" rel="noopener">Stateful, Stateless 위젯</a></li>
<li><a href="https://flutterbyexample.com/flutter-widgets#material-and-cupertino-widgets" target="_blank" rel="noopener">Materal, Cupertino</a></li>
<li><a href="https://flutterbyexample.com/flutter-widgets#most-common-widgets" target="_blank" rel="noopener">가장 일반적인 Widgets(Most Common Widgets)</a></li>
<li><a href="https://flutterbyexample.com/flutter-widgets#thinking-in-widgets" target="_blank" rel="noopener">위젯에서 생각하기(Thinking in Widgets)</a></li>
</ul>
<h2 id="what-s-a-widget">What’s a Widget</h2>
<p>플러터에선 모든게 위젯이다.</p>
<p>만약 여러분이 이전에 React나 Vue로 작업을 해봤다면 이것은 매우 쉬울 것이다. 플러터에서 모든것들이 <code>Widget</code> 이다. 재사용 가능한 작은 컴포넌트로 작업하는 것은 JS프레임워크와 매우 유사하다. 그리고 위젯은 플러터 클래스를 확장하는 다트 클래스에 지나지 않는다.</p>
<p>모든 플러터 위젯은 다음과 같다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ImageWidget extends StatelessWidget &#123;</span><br><span class="line">	// class stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위젯 클래스들은 오직 하나의 요구사항만 있다: 그것은 반드시 다른 위젯을 리턴하는 <code>build</code> 메소드를 가지고 있어야 한다는 것이다. 이 규칙의 유일한 예외는 기본타입(primitive types) (대개 Strings 또는 numbers)을 반환하는 <code>Text</code>와 같은 낮은 수준의 위젯이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BigText extends StatelessWidget &#123;</span><br><span class="line">	Widget build(context) &#123;</span><br><span class="line">		return new Text(&apos;text&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그외 위젯은 일반적인 다트 클래스 일뿐이다. 여러분은 위젯에 메소드와 속성 등을 추가 할 수있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class BigText extends StatelessWidget &#123;</span><br><span class="line">	// a property on this class</span><br><span class="line">	final String text;</span><br><span class="line"></span><br><span class="line">	// a constructor for this class</span><br><span class="line">	BigText(this.text);</span><br><span class="line"></span><br><span class="line">	Widget build(context) &#123;</span><br><span class="line">		// Pass the text down to another widget</span><br><span class="line">		return new Text(</span><br><span class="line">			text,</span><br><span class="line">			// Even changing font-style is done through a Dart class.</span><br><span class="line">			textStyle: new TextStyle(fontSize: 20.0),</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런 다음 앱의 다른 곳에서 위젯을 다음과 같이 사용하면 된다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">// This is how we&apos;d use the BigText within another widget.</span><br><span class="line">child: new BigText(&apos;This string would render and be big&apos;),</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<h2 id="stateless-and-statefulwidgets">Stateless and StatefulWidgets</h2>
<p>플러터 위젯은 플러터 라이브러리에서 몇 가지 클래스를 확장 해야 한다. 여러분이 사용할 둘은 거의 항상 <code>StatelessWidget</code>와 <code>StatefulWidget</code>이다.</p>
<p>둘간 차이점은 위젯 내에 상태(<code>state</code>)개념이 있고 그 중 일부가 변경되면 플러터에 다시 렌더링(re-rendering)을 지시하는 메소드가 내장 되어 있다는 것이다. 이것은 플러터의 핵심 개념이다.<br>
<code>Stateful</code> 위젯은 조금 달라 보인다. 사실 두 가지 클래스인 <code>state</code>객체와 위젯 이다. (역자주: <code>Stateless</code>위젯은 <code>StatelessWidget</code> 클래스만 상속 받으면 되지만 <code>Stateful</code>위젯은 <code>StatefulWidget</code>를 상속한 위젯 클래스와 위젯 생성시 내부적으로 사용되는 state객체를 생성하기 위한 <code>State</code>클래스를 상속받은 클래스 이렇게 두개가 필요함을 말한다.)</p>
<p>다음과 같이 작성하면 된다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Counter extends StatefulWidget &#123;</span><br><span class="line">  Counter(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">   // Stateful Widgets don&apos;t have build methods.</span><br><span class="line">   // They have createState() methods.</span><br><span class="line">   // Create State returns a class that extends Flutters State class.</span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; new _MyHomePageState();</span><br><span class="line"></span><br><span class="line">  // Stateful Widgets are rarely more complicated than this.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">	int counter = 0;</span><br><span class="line"></span><br><span class="line">	void increaseCount() &#123;</span><br><span class="line">		// setState is a special method that tells Flutter to repaint</span><br><span class="line">		// the view because state has been updated!</span><br><span class="line"> 		setState(() &#123;</span><br><span class="line"> 			this.counter++;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	// gotta have that build method!</span><br><span class="line">	Widget build(context) &#123;</span><br><span class="line">		return new RaisedButton(</span><br><span class="line">			onPressed: increaseCount,</span><br><span class="line">			child: new Text(&apos;Tap to Increase&apos;),</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="material-and-cupertino-widgets">Material and Cupertino Widgets</h2>
<p>플러터 SDK가 특별히 좋은점은 <code>Android</code>와 <code>iOS</code> 스타일의 위젯을 내장하고 있다는 것이다.<br>
감정을 분출해서 미안하지만(역자주: 글쓴이가 플러터에서 기본 제공하는 머터리얼과 쿠퍼티노 위젯 제공에 대해 너무 좋아함을 말하는듯함) 플러터가 상자에서 꺼내준것은 꽤 놀랍다. 여러분이 별도의 디자인 능력 없이도 꽤 보기 좋고 접근하기 쉬운 모바일 앱을 만들 수 있다.</p>
<p>만약 여러분이 새로운 React, Vue, React Native 등의 프로젝트를 시작했다고 상상해 보자. 그러면 디자인 표준을 염두에 둔 수백가지(수많은)의 구성 요소들이 필요할 것이다.<br>
이것이 Material과 Cupertino 위젯의 역할이다. Android앱처럼 보여주게 디자인된 Material과 iOS처럼 보여주게 디자인된 Cupertino.(역자주: 새로운 프로젝트를 위해서 수 많은 UI컴포넌트들이 필요한데 이런 작업들을 편리하도록 플러터는 Android와 iOS UI스타일에 맞게 디자인된 Material과 Cupertino 위젯음 기본 제공하므로 굉장히 편리하다.)</p>
<p>위젯에 내장된 이러한 기능과 완전한 사용자 정의 위젯을 만드는 능력은 당신에게 많은 힘(도움)을 준다. low-level custom 위젯으로 완전한 custom앱을 만들거나 MVP(역자주 : Minimum Value Product - 최소 기능 제품)에 도달하기 위해 주어진 기능을 사용하여 만들 수도 있다.</p>
<h2 id="most-common-widgets">Most Common Widgets</h2>
<p>다음은 즉시 사용할 준비가 된 위젯이다. 다음과 같은 위젯에 매우 익숙해 져야 한다.</p>
<ul>
<li>Text : 단순히 화면에 텍스트를 표시하는 위젯.</li>
<li>Image : 이미지를 표시.</li>
<li>Icon : 플러터의 내장된 Material과 Cupertino 아이콘을 표시.</li>
<li>Container : 플러터 UI에서 <code>div</code> 같은거라 보면 됌. 패딩, 정렬, 위젯의 크기 조절, 다른 것들의 boatloads(역자주: 앞서 설명한 요소들을 담을 수 있는것) 를 추가 할 수 있는 편리한 위젯. 비어 있을땐 0px 공간을 차지함.</li>
<li>TextInput : 사용자 의견을 처리.(역자주: 사용자 입력 폼)</li>
<li>Row, Column : 수평 또는 수직 방향으로 child(자식) 목록을 표시. 레이아웃을 위한 <code>flex-box</code> 규칙을 따른다.</li>
<li>Stack : 스택은 하나 이상의 다른 자식을 목록에 표시한다. 이 기능은 CSS의 <code>position</code> 속성과 매우 유사하다.</li>
<li>Scaffold : 앱의 기본 레이아웃 구조를 제공하는 앱내 모든 페이지의 root이다. <code>bottom navigations</code>(하단 메뉴), <code>appBar</code>(상단 타이틀 bar), <code>back buttons</code> (이전 버튼) 등을 쉽게 구현 할 수 있다.</li>
</ul>
<p>플러터의 위젯 문서는 굉장히 훌륭하다. <a href="https://flutter.io/widgets/" target="_blank" rel="noopener">목록</a>을 확인해 봐라.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">주의: 여러분이 React같은 컴포넌트 기반 프레임워크에 익숙하다면 내용을 읽지 않아도 된다. 위젯은 단지 컴포넌트 일 뿐이다.</span><br></pre></td></tr></table></figure>
<h2 id="thinking-in-widgets">Thinking in Widgets</h2>
<p>플러터에서 모든것이 위젯이다(역자주: 몇번에 걸쳐 말하는거 보니 엄청 중요하겠죠? ㅋ)<br>
위젯은 완벽한 앱을 만들기 위해 결합 할수 있는 아주 작은 UI덩어리 입니다. 플러터로 앱을 만드는 것은 레고 블록을 하나씩 조립해서 만드는것과 같다.<br>
위젯은 앱을 만들기 위해 내부에 서로 중첩된다. 여러분의 앱의 root 또한 위젯이며 모든 위제들은 하위로 쭉 내려간다.</p>
<p>플러터는 UI의 모든 측면(aspect)이 위젯으로 처리된다는 점에서 독특합니다.</p>
<p>위젯은 무언가를 표시하거나, 디자인을 정의하거나, 레이아웃 처리를 하거나, 상호 작용을 처리 할 수 있다. 다시 한번 강조하지만 플러터의 모든것은 <code>Widget</code> 이다.</p>
<ul>
<li>텍스트를 표시하는 간단한 위젯 : <code>const Text('Hello World')</code></li>
<li>사용자 상호작용을 처리하는 간단한 위젯 : <code>const Button(onTaps: ...callback...)</code></li>
<li>배경색상을 추가 하는 간단한 위젯 : <code>const BoxDecoration(background: Colors.blue)</code></li>
</ul>
<p>기본적으로 여러분의 CSS, HTML 및 자바스크립트가 모두 위젯에서 처리된다고 상상해 보자. 마크업이 없고, CSS도 없다. 오직 위젯이다.</p>
<h2 id="widget-hierarchy">Widget Hierarchy</h2>
<p>아래 그림에서 윤곽선으로 보이는 모든 것이 위젯이다.<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/v1527539536/flutter_by_example/thinking_in_widgets.png" alt="outlined widget"></p>
<p>이 그림은 <code>FlutterByExample</code>의 튜토리얼 앱 중 하나에서 가져온 것으로, 강아지(dog) 정보에 대한 세부 페이지 정보 이다.</p>
<p>녹색 윤곽선은 page를 나타낸다. 그리고 페이지는  플러터의 위젯이다. 파란색 윤곽선은 논리적으로 그룹화된 UI 조각을 나타낸다. 나머지는 흰색으로 윤곽이 그려져 있고, 이는 단순히 내용과는 상관없는 아둔한 컴포넌트(dump component)일 뿐이고, 이것들은 단지 그들이 전달받는 것을 보여줄 뿐이다.</p>
<p>다음은 이 페이지의 위젯 계층도 이다.</p>
<ul>
<li>PageWidget
<ul>
<li>DogProfileWidget</li>
<li>CircleImage</li>
<li>Text</li>
<li>Text</li>
<li>Text</li>
<li>Container
<ul>
<li>Icon</li>
<li>Text</li>
</ul>
</li>
</ul>
</li>
<li>RateDogWidget</li>
<li>Slider</li>
<li>Text</li>
<li>SubmitButton</li>
</ul>
<p><em>주의</em> 위 계층은 아주 정확하진 않다. 여기엔 <code>column</code> 및 <code>padding</code>과 같은 위젯도 있다.</p>
<h2 id="design-for-re-usability">Design for Re-usability</h2>
<p>플러터 위젯을 효과적으로 사용하는 가장 중요한 부분은 재사용 할 수 있도록 가장 저수준의 위젯을(lowest level) 디자인 하는 것이다.</p>
<p>예를들어 위 위젯계층 구조에서 <code>CircleImage</code> 위젯은 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CircleImage extends StatelessWidget &#123;</span><br><span class="line"> final String renderUrl;</span><br><span class="line"></span><br><span class="line"> CircleImage(this.renderUrl);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line">   return new Container(</span><br><span class="line">    width: 100.0,</span><br><span class="line">    height: 100.0,</span><br><span class="line">    decoration: new BoxDecoration(</span><br><span class="line">      shape: BoxShape.circle,</span><br><span class="line">      image: new DecorationImage(</span><br><span class="line">        fit: BoxFit.cover,</span><br><span class="line">        image: new NetworkImage(renderUrl ?? &apos;&apos;),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런 다음 앱의 어느 곳에서나 이 위젯을 다시 사용할 수 있다. 이렇게요 ( <code>new CircleImage(https...)</code> ) 이 컴포넌트는 재사용성을 고려 하여 설계 되었으므로 여러분은 특정 크기의 둥근이미지를 원하는 앱의 어느 곳에서든 url만 전달하면 사용할 수 있다. 그러므로, 굳이 이 위젯을 반복해서 다시 만들 필요는 없다.</p>
<p>추가적으로 이 원 이미지는(역자주: CircleImage 컴포넌트) 어떤 이미지를 나타내야 하는지 전혀 신경쓰지 않고 있다. 이것은 단지 컴포넌트의 스타일을 강제할 뿐이다.</p>
<p>다음 그림은 테스트앱에서 위 컴포넌트가 사용되어진 카드(card)중 하나이다.<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/v1527539533/flutter_by_example/Screen_Shot_2018-05-27_at_12.13.40_PM.png" alt="dogs_of_cards"></p>
<p><a href="https://github.com/ericwindmill/flutter_by_example_apps/tree/master/basic_flutter_app" target="_blank" rel="noopener">예제소스</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/24/flutter-study-widgets/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/24/flutter-study-widgets/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/24/flutter-setup-and-tools/">
                            Flutter 설정 및 도구
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-24T16:43:44+09:00">
	
		    Jan 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Setup and Tools(설정과 도구들)</h1>
<p>플러터를 사용하기 위한 첫번째 단계는 <code>Dart</code>설치를 포함하는 플러터 SDK를 설치하는 것이다. 이 <a href="https://flutter.io/docs/get-started/install" target="_blank" rel="noopener">가이드</a> 를 따라 시작하시오.</p>
<h2 id="choose-an-editor-with-dart-plugins-다트-플러그인을-포함한-에디터-선택">Choose an Editor with Dart Plugins (다트 플러그인을 포함한 에디터 선택)</h2>
<p>여러분이 다트 코드를 작성하려고 할때 어떤 text에디터든 사용할 수 있지만 플러터가 지원되는 IDE를 선택하면 훨씬 더 생산적인 경험을 할 수 있다. 내가 제안할 두 가지는 다음과 같다.</p>
<ol>
<li>IntelliJ Idea<br>
나는 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">JetBranis의 IntelliJ IDEA</a>를 적극 추천한다. community edition은 무료임.<br>
이 IDE는 코드완성, 스니펫(snippets), 오류강조, 린팅(linting) 등 어떤 언어든 원하는 모든 멋진 기능을 제공한다. 또한 죽여주는 디버깅 기능을 얻을게 될 것이고, 디버그 도구에는 브라우저 dev-tools 스타일 검사기 등이 있다.<br>
(역자주: 저의 경우 android studio에 flutter, dart플러그인 설치하는게 더 좋은것 같음.)</li>
</ol>
<p>IntelliJ를 사용하려면 IntelliJ 내에 Dart 및 Flutter 플러그인을 설치해야한다.<br>
<img src="https://res.cloudinary.com/ericwindmill/image/upload/v1518914480/flutter_by_example/inspector_screenshot.png" alt="IntelliJ IDEA"><br>
위젯 트리를 보여주는 플러터 검사기 - 브라우저의 dev tools의 HTML보기와 유사하다.</p>
<ol start="2">
<li>VS Code<br>
다트 커뮤니티는 플러터 기능을 지원하는 VS코드용 다트 플러그인을 만들었다. 그것은 강력하지는 않지만 좋은 대안이 될 수 있다.<br>
(역자주: 기존에 IDEA을 사용해오셨다면 고생하지 마시고 그냥 Android Studio에 플러터, 다트 플러그인 설치해서 사용하세요.)</li>
</ol>
<ul>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.dart-code" target="_blank" rel="noopener">VSCode용 다트 플러그인</a></li>
</ul>
<h2 id="pub-and-libraries">Pub and Libraries</h2>
<p><code>pub</code>는 다트 패키지 관리 시스템이다. 다트 및 플러터에서 사용 가능한 모든 패키지를 검색하고 정보를 얻을 수 있는 웹사이트가 있다.<br>
<a href="https://pub.dartlang.org/" target="_blank" rel="noopener">다트 Pub 패키지</a></p>
<h2 id="gitter">Gitter</h2>
<p>문제가 발생하면 <a href="https://gitter.im/flutter/flutter" target="_blank" rel="noopener">플러터 Gitter채널</a>에서 실시간으로 도움을 요청 할 수 있다. 그곳에서 구글의 플러터 팀 구성원과 플러터를 지지하는 팬 커뮤니티를 찾을 수도 있을 것이다.</p>
<h2 id="flutter-docs">Flutter Docs</h2>
<p>마지막으로 나는 플러터의 문서가 내가 만난 최고 중 하나라고 진심으로 생각한다. <a href="https://flutter.io/widgets/" target="_blank" rel="noopener">Flutter Widget Docs</a></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/24/flutter-setup-and-tools/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/24/flutter-setup-and-tools/" data-numposts="10"></div>
</section>

    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2019/01/22/flutter-study-about-flutter/">
                            Flutter란?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-22T19:11:08+09:00">
	
		    Jan 22, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/flutter/">flutter</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>본 문서는 <a href="https://flutterbyexample.com" target="_blank" rel="noopener">Fluter Example</a>의 내용을 원저작자의 동의하에 번역한것 입니다.<br>
원 저작자 Eric Windmill에게 감사를 전합니다.<br>
이해하는데 불필요한 문장은 과감하게 버렸습니다. 오 번역에 대해서 의견 주시면 적극 반영 하겠습니다.</p>
</blockquote>
<h1>Flutter란?</h1>
<p><a href="https://flutter.io" target="_blank" rel="noopener">Flutter</a>는 모든 사람이 아름다운 모바일 앱을 개발 할 수 있도록 지원하는 모바일 SDK이다.<br>
여러분이 웹개발자 이든 native 모바일 개발자 이든 관계없이 프레임워크 (역자주: android, ios, React native, Vue native…)을 사용 하지 않고 친숙하고 단순한 방식으로 모바일 앱을 보다 쉽게 만 들 수 있다.</p>
<p>이글을 쓰는 시점에서 <code>Google AdWords</code>와 <code>Alibaba</code> 모두 플러터를 사용하고 있다.<br>
플러터 웹사이트의 <a href="https://flutter.io/showcase" target="_blank" rel="noopener">showcase 페이지</a>에서 플러터의 사용예를 볼 수 있다.</p>
<p>요즘 플러터에 대해 말이 많다. 내가 종종 봤던 질문은 <code>&quot;Flutter랑 React Native 중에 어떤걸 사용해야 하냐?&quot;</code> 이다.<br>
모든 프로그래밍이 다 그렇지만 여러분이 무언가 하고자 하면 그것에는 trade-off(이율 배반)가 따르기 마련이다.</p>
<p>나는 여러분에게 플러터가 모바일 앱 개발을 위한 최선의 선택이라는 것을 확신 시키기 위해 노력할 것이다.</p>
<p>나는 플러터가 다른 <code>cross platform framework</code>보다 뛰어나다고 믿으며 아마 native 개발보다 나을것이다. ( - 약간의 설명이 필요하긴 함. )</p>
<p>그전에 <a href="https://www.dartlang.org/" target="_blank" rel="noopener">Dart</a> 프로그래밍 언어 부터 시작해서 플러터가 무엇인지에 대해 빠르게 살펴 보겠다.</p>
<h2 id="dart란">Dart란?</h2>
<p><a href="https://www.dartlang.org/" target="_blank" rel="noopener">Dart</a>는 구글에서 만든 프로그래밍 언어로 플러터를 작성하는데 사용됐다.<br>
다트는 구글이 <code>server side</code>및 <code>front-end</code>코드를 작성하는데 <code>Javascript</code> 보다 더 나은 언어를 원했기에 만들어 졌다.</p>
<p>내가 알기로는, 자바스크립트의 가장 큰 문제는 승인을 위한 거대 위원회와 이를 구현하기 위한 여러 브라우저 공급업체에 의존하고 있기 때문에 새로운 기능 업데이트가 느리다는 것이다.</p>
<p>구글은 자바스크립트를 직접 사용할지 말지에 대한 일련의 결정 후에 의미적으로 자바스크립트와 맞는 언어를 만들기로 결정했다. 다시 말하자면 다트에서 작성되는 모든것은 자바스크립트로 컴파일 할 수 있으며 이것이 구글이 <code>Java</code>를 사용하지 않고 새로운 언어를 개발한 이유이다. - 이것은 큰 의미를 갖는다.</p>
<blockquote>
<p><a href="https://gist.github.com/paulmillr/1208618" target="_blank" rel="noopener">링크</a>는 2010년 구글에서 유출된 이메일 체인 이다. 그들이 자바스크립트에 대해 뭔가 해야 한다는걸 결정한 것은 <code>예수께 이르는</code> 순간 이다.(역자주: 예수께 이르다는것은 무엇으로 부터 구원을 받은~ 으로 이해했음)</p>
</blockquote>
<p>하지만 좋은 소식이 있다. 다트는 <code>safe</code> 언어를 배우는 데 탁월하다. 구글은 다트로 어떤 혁신적인것을 만들기 위해 시작하지 않았다. 그들은 단순하고 생산적이며 자바스크립트로 컴파일 될 수 있는 언어를 만들고자 했다.</p>
<p>구문에는 특별히 흥미로운것도 없으며 여러분을 혼란스럽게 할 특별한 연산자도 없다.<br>
다트(자바스크립트와는 달리)에는 <code>true</code>와 <code>false</code>를 한 가지 방법으로만 표현한다.</p>
<p>자바스크립트에서 다음은 true로 인식된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (3) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>다트에선 위 처럼 하면 프로그램이 엉망이 될것이다. 다트의 핵심은 생산적이고 예측 가능하며 간단한 언어라는 것이다. 이것은 중요하다, 왜냐면 플러터에서 앱을 작성하는것은 단순히 다트를 작성하는 것이기 때문이다. 플러터는 하부에 다트 라이브러리 클래스들이 있다. <code>markup 언어</code>와 관련됐거나 <code>JSX</code>스타일의 하이브리드 언어는 없다. 모든 프론트 엔드 코드는 다트로 작성된다. No HTML, No CSS.</p>
<h2 id="플러터가-다트를-사용하는-이유는">플러터가 다트를 사용하는 이유는?</h2>
<p>만약 여러분이 다른 기술배경을 사용해봤다면 아마도 플러터가 자바스크립트가 아니라 다트를 사용한다는 사실에 대해 불평했을 것이다. (개발자들은 믿거나 말거나 독단적이다.)<br>
그리고 이 선택에 회의적인 이유는 있다. 다트가 오늘날 가장 많이 사용되는 25개 언어에 포함되지 않는 인기 없는 언어라는 것이다. “뭐라구요? 구글이 자사 언어라서 사용했다구요?” 나는 그것도 맞는 소리라고 생각하지만 실용적인 이유도 있다.</p>
<ul>
<li>다트는 JIT(Just In Time)컴파일과 AOT(Ahead Of Time)컴파일을 모두 지원한다.
<ul>
<li>AOT컴파일러는 다트코드를 효율적인 native 코드로 바꾼다. 이것은 플러터를 빠르게 만들지만,(사용자와 개발자에게 승리) 거의 모든 프레임워크가 다트로 작성되었음을 의미 한다. 여러분 즉 개발자가 모든 것을 커스터마이징한다는 것이다.</li>
<li>다트의 옵션인 JIT컴파일은 <code>hot-reloading</code>을 가능케 한다. 빠른 개발과 반복은 플러터 사용 즐거움의 핵심이다. 텍스트 편집기에 코드를 저장하면 시뮬레이터상의 앱이 1초 이내에 업데이트 된다.</li>
</ul>
</li>
<li>다트는 객체 지향이다. 이것은 다트만으로 시각적 사용자 경험(UX)을 쉽게 작성 할 수 있게 해주며, <code>markup language</code>는 필요치 않다.</li>
<li>다트는 생산적이고 예측 가능한 언어이다. 배우기 쉽고 친숙하다. 여러분이 <code>동적언어(dynamic language)</code>를 사용해 왔든 <code>정적언어(static language)</code>를 사용해 왔든 쉽게 시작 할 수 있다.</li>
<li>그리고 나는 같은 회사에서 만든 언어를 사용하는 것이 매우 매력적이라는 생각이 들기도 한다. 왜냐면 플러터 팀은 다트 팀과 긴밀히 협력하여 필요로 하는 새로운 기능을 구현할 수 있었기 때문이다.</li>
</ul>
<h2 id="flutter-vs-react-native-및-기타-선택">Flutter vs. React Native ( 및 기타 선택 )</h2>
<p>여러분의 다른 선택에 대한 나의 의견을 제시하기 전에 이것을 분명히 말하고 싶다. 플러터는 100% 정답이 아니다. 그것은 도구이고 우리는 당면한 일에 적합한 도구를 선택해야 한다는것이다. 즉 나는 이것이 미래에 여러분이 강력하게 고려해야 할 것이라고 주장 할뿐이다.</p>
<h2 id="native-develoment-ios-and-android">Native develoment(iOS and Android)</h2>
<p>여러분의 첫번째 선택은 <code>iOS</code>와 <code>Android</code> native앱을 쓰는 것이다. 이것은 최대한의 제어와 디버깅 도구, 그리고 (잠재적으로) 성능 좋은 앱을 제공한다. 이말은 회사에서 모든것(개발대상)을 각 플랫폼마다 한번씩, 두번 작성(개발)해야 한다는 것을 의미한다. 여러분이 서로 쉽게 도울 수 없는 다른기술을 가진 다른팀의 다른 개발자가 필요할 것이다.</p>
<h2 id="react-native-webviews-and-other-cross-platform-javascript-options">React Native, WebViews, and other cross-platform JavaScript options</h2>
<p>여러분의 두번째 선택은 <code>WebViews</code>나 <code>React Native</code>와 같은 자바스크립트 기반의 <code>cross-platform</code> 이다. 이건 나쁜 선택이 아니다. 네이티브 개발로 겪는 문제가 사라진다. 팀의 모든 프론트엔드 웹 개발자는 최신 자바스크립트 기술만 알고 있으면 이를 지원(사용)할 수 있다.<br>
AirBnb, Facebook, Twitter와 같은 대기업들이 <code>React Native</code>를 핵심 제품(서비스)에 사용한 것도 이런 이유에서이다. (AirBnb는 최근 아래 설명할 몇가지 이유로 인해 React Native 사용을 중지 한다고 <a href="https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a" target="_blank" rel="noopener">발표</a>했다.</p>
<p>첫번째 모바일 앱은(Airbnb의) <code>WebKit</code>(브라우저 렌더링 엔진)에서 실행되는 간단한 <code>WebViews</code> 였다. 문자 그대로 내장된 웹페이지다. 이것의 문제는 기본적으로 DOM조작이 매우 비싸고 훌륭한 모바일 경험(UX)을 만들 만큼 성능이 좋지 않다는 것이다.</p>
<p>일부 플래폼에선 <code>Javascript Bridge</code>를 구축하여 이런 문제를 해결 했다. 이 브릿지는 자바스크립트가 네이티브 위젯과 직접 대화(통신) 할 수 있게 한다.</p>
<p>이것은 <code>WebViews</code>보다 훨씬 더 뛰어난 성능을 발휘 하지만 여전히 이상적이진 않다.<br>
앱이 렌더링 엔진과 직접 대화(통신)할때 마다 브릿지를 위해 네이티브 코드로 컴파일 되어야 한다.<br>
단일 상호 작용에서 브릿지는 두 번 교차해야 한다. 한번은 플랫폼에서 앱으로 그리고 다시 앱에서 플랫폼으로.<br><br><br>
<img src="https://css-tricks.com/wp-content/uploads/2018/08/flutter-01.png" alt="Single interaction"></p>
<p>플러터는 <code>Chrome</code>에서 사용하는것과 동일한 렌더링 엔진인 <a href="https://skia.org/" target="_blank" rel="noopener">Skia</a>를 자체 렌더링 엔진으로 사용하기 때문에 다르다. <code>Skia</code>는 플러터 앱과 통신 할 수 있다. 그 결과 로컬 이벤트를 자바스크립트로 먼저 컴파일 할 필요 없이 직접 받아 들인다.<br>
플러터가 native ARM코드로 컴파일 되기 때문에 가능하고 이것이 성공의 비결이다. 여러분의 앱이 사용자의 장치에서 작동되면 이 앱은 전적으로 장치의 운영체제가 기대하는 언어로 실행된다.<br><br><br>
<img src="https://css-tricks.com/wp-content/uploads/2018/08/flutter-02.png" alt=""></p>
<p><code>Javascript bridge</code>는 확실히 현대적 프로그래밍의 경이로운 부분이지만, 세 가지 큰 문제가 존재한다. <br><br>
첫번째 문제는 디버깅이 어렵다는 것이다. 런타임 컴파일러에 오류가 있을 경우 해당 오류를 자바스크립트 브릿지를 통해 추적하여 자바스크립트 코드에서 찾아야 한다. 그것은 마크업 또는 CSS와 같은 구문 일 수도 있다. 디버거는 우리가 원하는 만큼 잘 작동하지 않을 수도 있다.</p>
<p>두번째로 큰 문제는 성능이다. 자바스크립트 브릿지는 매우 비싸다. 앱에서 무언가 탭(tapped)될 때마다 해당 이벤트가 브릿지를 통해 자바스크립트 앱으로 전송되어야 한다. “적절한 용어를 찾지 못하겄다! 걍 jank다.” (jank는 품질에 문제가 있는것들을 의미함. )</p>
<p>세번째로 큰 문제는 <a href="https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a" target="_blank" rel="noopener">AirBnb에 따르면</a> 그들은 자신들이 원하던 것보다 더 자주 native 코드를 까봐야 한다는 것을 발견했다고 한다. 그것은 대부분 자바스크립트 개발자로 구성된 팀들의 문제였다.</p>
<h2 id="플러터의-즉각적인-이점">플러터의 즉각적인 이점</h2>
<p>이 글을 읽고 있으니 플러터에 관심이 있을 수도 있지만… 회의적일 수도 있다. 나는 여러분의 철저한 기술조사에 존경(감탄) 한다.<br>
여러분의 회의적인 이유는 타당하다. 그것은 새로운 기술이다. 이는 API의 변경사항을 깨뜨리는 것을 의미 한다. 이는 중요한 기능 (예: 구글지도)에 대한 지원이 누락 되었음을 의미한다. 구글이 언젠가 그것을 포기 할 수도 있다.</p>
<p>그리고 여러분이 다트가 훌륭한 언어라고 믿는 사실에도 불구하고, 다트가 널리 사용되지 않고 여러분이 원하는 <code>third-party</code> 라이브가 존재하지 않을 수도 있다는 사실은 변하지 않는다.</p>
<p>하지만 나는 그 모든 점들에 대해 논쟁을 벌일 것이다. 구글은 <code>Google AdWords</code>를 포함한 주요 수익 창출 앱에서 내부적으로 플러터를 사용하기 때문에 API는 바뀔것 같지 않다.</p>
<p>다트는 최근 버전2로 변경됐고, 이는 대 규모 변경이 있기까진 시간이 걸릴 것이라는걸 의미한다.<br>
컴퓨터 세계에서 사실상 영구적인 변경이 소개 되기까지는 수년이 걸리지 않는가…</p>
<p>맞습니다. 실제로 누락된 기능들도 있지만 플러터는 여러분에게 여러분 고유의 native 플러그인을 추가 할 수 있는 완전한 제어권을 제공한다.<br>
사실 <code>map</code>, <code>camera</code>, <code>location service</code>, <code>device storage</code>와 같은 가장 중요한 <code>operationg system</code>플러그인은 이미 존재한고 다트와 플러터의 생태계 커뮤니티도 이미 존재한다. 물론 자바스크립트 커뮤니티보다 훨씬 작지만 간결하다고 주장 하고 싶다. 나는 매일 새로운 패키지를 만드는 대신 기존 패키지에 기여 하는 사람들을 봤다.</p>
<p>이제 플러터의 구체적인 이점에 대해 얘기해 보자.</p>
<h2 id="no-javascript-bridge">No JavaScript bridge</h2>
<p>이것은 개발 및 응용프로그램 성능의 주요 병목이다. 다시 말하지만 이것은 jank로 이어진다. (위에도 jank에 대해 언급 했지만 한마디로 x같다.임)<br>
스크롤이 매끄럽지 않고 항상 성능이 좋은것도 아니고 디버깅 하기도 어렵다.</p>
<p>플러터는 실제 native코드로 컴파일 되고 Skia를 사용해서 렌더링 된다. 앱 자체도 native로 실행되므로 다트를 native로 변환할 이유가 없다.<br>
이는 사용자의 기기에서 실행될 때 어떠한 성능이나 생산성을 잃지 않는다는것을 의미한다.</p>
<h2 id="compile-time">Compile time</h2>
<p>여러분이 만약 native개발자 라면, 여러분의 큰 고통 중 하나는 개발주기 였을겁니다. <code>iOS</code>의 미친 컴파일 시간은 악명이 높다. 플러터에서 전체 컴파일은 일반적으로 30초 미민이며, 핫 리로드 덕택에 증분 컴파일은 초 단위 이다. 플러터의 이런 개발주기 덕분에 우리는 모바일 클라이언트를 위한 기능을 빠르게 개발 할 수 있게 되었다. 구현히 확실할때만 웹 클라이언트에 이러한 기능을 개발한다.</p>
<h2 id="write-once-test-once-deploy-everywhere-한번의-개발-한번의-테스트-어디에나-배포">Write once, test once, deploy everywhere (한번의 개발, 한번의 테스트, 어디에나 배포)</h2>
<p>앱을 한 번만 작성하고 <code>iOS</code> 및 <code>Android</code>에 배포 할뿐만 아니라 테스트를 한번만 작성하면 된다. 다트 unit테스트는 아주 빠르고 플러터는 테스트용 <code>Widget</code>들을 포함하고 있다.</p>
<h2 id="code-sharing-코드-공유">Code sharing (코드 공유)</h2>
<p>나는 여기서 공평해질꺼다. 나는 이것이(코드공유) 자바스크립트에서도 기술적으로 가능하다고 생각한다. 하지만 확실히 native개발에선 불가능하다. 플러터와 다트를 사용하면 웹 및 모바일 앱이 각 클라이언트들의 뷰를 제외한 모든 코드를 공유 할 수 있다.(물론, 다트를 통해서 웹 앱을 만든 경우에만 해당). 의존성 삽입을 사용하여 동일한 <code>model</code>과 <code>controller</code>를 <code>AngularDar</code>앱과 플러터 앱을 쉽게 실행 할 수 있다.</p>
<p>물론 웹앱과 모바일 앱간에 코드 공유를 하고 싶지 않더라도 모든 코드를 <code>iOS</code>와 <code>Android</code>앱간에 공유 할 수 있다.</p>
<p>실용적인면에서 이것은 여러분이 매우 생산적이라는것을 의미 한다. 앞서 말했지만 우리 회사는 먼저 모바일 기능을 개발한다. 왜냐면 웹과 모바일간에 비지니스 로직을 공유하기 때문에 일단 모바일 기능이 구현되면 동일한 컨트롤러 데이터를 필요로 하는 <code>view</code>만 작성하면 되기 때문이다.</p>
<h2 id="productivity-and-collaboration-생산성과-공동작업">Productivity and collaboration (생산성과 공동작업)</h2>
<p><code>iOS</code> 및 <code>Android</code>용 팀이 분리 되는 시대는 끝났다. 사실 여러분이 여러분의 웹 앱에서 다트를 사용하든, 자바스크립트를 사용하든 간에, 플러터 개발은 여러분의 모든 팀이 통합될 정도로 충분히 친숙하다. 자바스크립트 웹 개발자가 플러터와 다트에서도 효과적으로 개발할 것으로 기대하는건 결코 쉬운 일이 아니다. 여러분이 나를 믿는다면, 여러분의 새로운 통합팀은 3배 더 생산적인 팀이 될 것 이다.</p>
<h2 id="code-maintenance-코드-유지보수">Code maintenance (코드 유지보수)</h2>
<p>버그를 한번 고치는게 모든 <code>client</code>를 고친는것 보다 났다는것은 두말 하면 잔소리지만 매우 특정한 경우에 한해선 플러터로 제작된 <code>iOS</code>앱에 버그가 있다면 <code>Android</code> 버전에도 존재한다. (반대의 경우도 마찬가지) 이런한 경우 100% 이러한 버그는 버그가 아니라 내장된 위젲의 기기 OS설계 시스템을 따르기 때문에 외관상의 문제가 된다. 이러한 문제는 텍스트 크기 조정 또는 정렬과 같은 문제이기 때문에 엔지니어링 시간을 사용하여 수정하는 맥락에서 보면 사소한 것이다.</p>
<h2 id="flutter-for-javascript-developers-자바스크립트-개발자들을-위한-플러터">Flutter for JavaScript developers (자바스크립트 개발자들을 위한 플러터)</h2>
<p><code>CSS-Tricks</code>를 읽어 있으니 나는 여러분이 웹 개발자라 확신한다.(역자주: <code>CSS-Tricks</code>가 뭔지를 모르겠음) 만약 여러분이 오늘날 가장 인기 있는 <code>framework</code>을 사용한다면, 여러분이 플러터를 줍는게(공부하는게) 쉽다는 것을 알게 되어 기뻐할 것이다.</p>
<p>플러터는 완전히 반응형(<code>reative</code>)이기 때문에 <code>React</code>에서 익숙해진 동일한 사고방식과 패러다임이 플러터로 이어진다.<br>
여러분은 기본적으로 <code>React</code>처럼 재사용할 수 있는 수 많은 컴포넌트(풀루터에선 <code>Widget</code>이라고 부름)를 만들고 있을 것이다. 이 위젯들은 라이프 싸이클(<code>life cycle</code>)메소드로 완성되며, 클래스(<code>class</code>)로 작성된다.</p>
<p><code>React</code>에서 이 구문을 사용한 경우:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const MyComponent extends React.Component &#123;</span><br><span class="line">  //...</span><br><span class="line">  render()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…그리고 아무 문제 없이 플러터를 잡을 것이다. 플러터에서 동일한 작업을 수행하는 방법은~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MyWidget extends StatelessWidget &#123;</span><br><span class="line">  //...</span><br><span class="line">  build()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 React와 마찬가지로 플러터에서도 상속(<code>inheritance</code>)보다는 구성(<code>composition</code>)을 선호한다.<br>
예를 들어 여러분이 React에서 특별한 <code>AddToCartButton</code>을 만들기 원한다면, <code>JSX</code>의 특별한 함수와 스타일을 사용하여 버튼을 만들 수 있다. 플러터에서도 정확히 그렇게 하는 거다. (JSX는 제외하고~)</p>
<p>마지막으로 플러터의 레이아웃(<code>Layout</code>) 시스템은 우리에게 익숙한 CSS규칙, 즉 flexbox와 절대위치 지정(absolute positioning)과 비슷하다.<br>
이것은 또한 플러터의 <code>view</code>를 만드는데 있어 큰 차이점이 있다. 플러터에선 문자 그대로 모든것이 위젯(<code>Widget</code>)이다. <code>Text</code>, <code>Button</code> 및 <code>AppBar</code>와 같은 명확하고 구체적인 위젯이 있고 <code>Animations</code>, <code>Layout</code> 또한 위젯이다. <code>Text</code>를 가운데로 정렬하기 위해 <code>Center</code>위젯으로 <code>Text</code> 위젯을 감싼다. 패딩(padding)을 추가하려면 <code>Padding</code>이 있다.</p>
<p>React 앱을 가능한 가장 작은 재사용 가능한 구성 요소로 분해 한다고 상상해 보자. 예를 들어 여러분이 단순히 <code>Padding</code> 속성을 다루는 고차원의 React 컴포넌트를 만든 경우 그 중첩된 패딩을 해당 패딩 양만큼 추가하면 된다. 이것이 CSS나 마크업 없이 플러터가 작동하는 방식이다.</p>
<p>이 샘플 그림에서는 사용할 수 있는 몇 가지 레이아웃 위젯을 설명하지만 사용자로서 '참조’할 수는 없다:</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/08/flutter-03.jpg" alt="Examplelayout"><br>
엄청나게 단조로운 작업처럼 보일 수 도 있지만, 플러터에는 (<code>Padding</code>과 <code>Center</code>와 같은) 내장된 아주 많은 위젯들이 있기 때문에 여러분은 쓸때 없이 시간을 낭비할 필요가 없다.</p>
<p>다음은 가장 일반적인 위젯 중 하나이다.</p>
<ul>
<li><a href="https://flutter.io/widgets/layout/" target="_blank" rel="noopener">레이아웃</a> : <code>Row</code>, <code>Column</code>, <code>Scaffold</code>, <code>Stack</code></li>
<li><a href="https://flutter.io/docs/development/ui/widgets/material#App%20structure%20and%20navigation" target="_blank" rel="noopener">구조</a> : <code>Button</code>, <code>Toast</code>, <code>MenuDrawer</code></li>
<li><a href="https://flutter.io/docs/development/ui/widgets/text" target="_blank" rel="noopener">텍스트</a> : <code>FadeInPhoto</code>, transformations</li>
<li><a href="https://flutter.io/docs/development/ui/widgets/styling" target="_blank" rel="noopener">스타일링</a> : <code>Center</code>, <code>Padding</code></li>
</ul>
<h2 id="final-note">Final note</h2>
<p>플러터를 사용해 보겠는가?<br>
만약 여러분이 버터같은 부드러운 모바일 앱을 익숙한 스타일로 만들고 싶다면, Yes! 성능과 개발자 경험 모두 플러터에서 완전하게 유지된다.<br>
애니메이션은 60fps에 달하며 내장된 <code>Cupertino-style</code> 및 <code>Material Design-style</code>의 위젯이 번들로 제공되며 간단히 말해, native 성능을 희생하지 않고 플러터에서 얼마나 빨리 생산적으로 작업 할 수 있는지는 믿기 힘들정도 이다.</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2019/01/22/flutter-study-about-flutter/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
        <div style="padding-bottom: 5px; border-bottom: 1px solid #eef2f8">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png"></a><br>이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/2.0/kr/">크리에이티브 커먼즈 저작자표시-비영리-변경금지 2.0 대한민국 라이선스</a>에 따라 이용할 수 있습니다.
</div>

        <section id="comments">
<div class="fb-comments" data-href="
http://jaceshim.github.io/2019/01/22/flutter-study-about-flutter/" data-numposts="10"></div>
</section>

    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Jace Shim. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/profile.jpg" alt="Author&#39;s picture">
        
            <h4 id="about-card-name">Jace Shim</h4>
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                Seoul, Korea
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-t7ijpwgqnsx79bzheqqud5n5dakbwan6eiq5msjhe0zsxvect7dvc4pvkcpc.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
